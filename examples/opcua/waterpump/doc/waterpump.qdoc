/****************************************************************************
**
** Copyright (C) 2018 basysKom GmbH, info@basyskom.com
** Contact: https://www.qt.io/licensing/
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \example waterpump
    \ingroup qtopcua-examples
    \title Using Qt OPC UA in a basic UI application

    \section1 Introduction
    This example shows how to use Qt OPC UA to interact with an OPC UA
    server to build a QML based HMI for a simple machine.

    \section1 The simulation
    The OPC UA server included in this example runs a simulation of a machine
    containing two tanks, a water pump and a valve. Water can be pumped from the
    first tank into the second tank and then be flushed from the second tank
    by opening the valve. Both operations have a user-configurable setpoint
    which controls how much water is pumped to or flushed from the second tank.

    The following nodes exist on the server:

    \table
        \header
            \li NodeId
            \li Function
        \row
            \li ns=2;s=Machine
            \li The folder containing the method and variable nodes for the machine
        \row
            \li ns=2;s=Machine.State
            \li The state of the machine
        \row
            \li ns=2;s=Machine.Tank1.PercentFilled
            \li The current fill status of the first tank
        \row
            \li ns=2;s=Machine.Tank2.PercentFilled
            \li The current fill status of the second tank
        \row
            \li ns=2;s=Machine.Tank2.TargetPercent
            \li The setpoint for pumping and flushing
        \row
            \li ns=2;s=Machine.Tank2.ValveState
            \li The state of the valve of the second tank
        \row
            \li ns=2;s=Machine.Designation
            \li A human readable designation of the machine for display purposes
        \row
            \li ns=2;s=Machine.Start
            \li Call this method to start the pump
        \row
            \li ns=2;s=Machine.Stop
            \li Call this method to stop the pump
        \row
            \li ns=2;s=Machine.FlushTank2
            \li Call this method to flush tank 2
    \endtable

    All methods return \l {QOpcUa::UaStatusCode} {Good} in case of success and
    \l {QOpcUa::UaStatusCode} {BadUserAccessDenied} if the operation is illegal
    (e. g. trying to start the pump if the first tank is empty).

    \section1 Used features of \l QOpcUaClient
    This example uses read, write, method calls and data change subscriptions
    and shows how to set up handlers for the asynchronous operations offered
    by QOpcUaClient and QOpcUaNode.

    \section1 Implementation

    A backend class is used to handle the communication with the OPC UA server
    and expose the content of this server by means of properties and Q_INVOKABLE
    methods wrapping the OPC UA method calls.

    \section2 Member variables
    A pointer to \l QOpcUaClient is required for connection management. An
    additional pointer to a \l QOpcUaNode object is needed for each OPC UA
    node the HMI interacts with. For the values of these nodes, member variables
    containing the last value reported by the server are added.

    \quotefromfile waterpump/qml-hmi/opcuamachinebackend.h
    \dots
    \skipto m_client
    \printuntil m_machineDesignation;
    \codeline
    \dots

    For each value used in the HMI, a getter, a changed signal and a
    property are added to enable property bindings in QML

    \quotefromfile waterpump/qml-hmi/opcuamachinebackend.h
    \dots
    \skipto Q_PROPERTY
    \printuntil QString message
    \dots

    \section2 Asynchronous handlers

    The asynchronous API of Qt OPC UA requires signal handlers for all operations.

    Data change subscriptions report their updates using \l QOpcUaNode::attributeUpdated.
    A handler connected to this signal gets the new value as QVariant and can
    e. g. write that value to a variable or emit a signal with the new value.

    \quotefromfile waterpump/qml-hmi/opcuamachinebackend.cpp
    \skipto void OpcUaMachineBackend::percentFilledTank1Updated
    \printuntil }

    A read operation emits the \l QOpcUaNode::attributeRead signal on completion.
    The client has to check the status code and then get the result from the node.

    \skipto void OpcUaMachineBackend::machineDesignationRead
    \printuntil }
    \printuntil }
    \printuntil }

    \section2 Interaction with the server

    In the constructor, a QOpcUaProvider is created and the available backends are saved to provide a model for the backend selection dropdown menu.

    \quotefromfile waterpump/qml-hmi/opcuamachinebackend.cpp
    \dots
    \skipto QOpcUaProvider provider
    \printuntil setBackends
    \dots

    Before attempting a connection, a QOpcUaClient with the selected backend is created. Its \l QOpcUaClient::stateChanged signal must be
    connected to the backend's clientStateHandler slot.

    \quotefromfile waterpump/qml-hmi/opcuamachinebackend.cpp
    \skipto OpcUaMachineBackend::connectToEndpoint
    \printuntil m_client->connectToEndpoint
    \printuntil }

    clientStateHandler acts on QOpcUaClient being connected or disconnected.
    In case of a successful connection, the node member variables created before
    are filled with node objects.

    \dots
    \quotefromfile waterpump/qml-hmi/opcuamachinebackend.cpp
    \skipto if (state == QOpcUaClient::ClientState::Connected) {
    \printuntil m_machineDesignationNode
    \dots

    After all node objects have been created, the data change handlers are
    connected to the node objects and monitoring is enabled.

    \dots
    \skipto Connect signal handlers
    \printuntil m_tank2ValveStateNode->enableMonitoring
    \dots

    The machine designation is not supposed to change and will be read once at
    startup.

    \dots
    \skipto Connect the handler for async reading
    \printuntil m_machineDesignationNode->readAttributes
    \codeline
    \dots

    A setter for the setpoint is added to the backend.

    \skipto machineWriteTank2TargetPercent
    \printuntil }

    For the methods, wrappers which call the OPC UA server method are created.

    \skipto startPump
    \printuntil }

    \section2 The HMI

    A backend instance is created and handed to the QML part as a context property
    named uaBackend.

    \dots
    \quotefromfile waterpump/qml-hmi/main.cpp
    \skipto     OpcUaMachineBackend backend
    \printuntil setContextProperty
    \dots

    The properties, signals and Q_INVOKABLE methods of uaBackend can now be accessed by
    the QML code. For example, the button to flush the second tank is enabled
    only if the backend is connected to the server, the machine is idle and
    the tank level is above the setpoint. On click, the flushTank2() method
    is called on the server.

    \quotefromfile waterpump/qml-hmi/Tank2Unit.qml
    \skipto     Button
    \printuntil }
    \printuntil }

    Signals from the backend can also be used directly in the QML code.

    \quotefromfile waterpump/qml-hmi/Pump.qml
    \skipto Connections
    \printuntil }
    \printuntil }

    \section1 Usage
    The server is started automatically by the HMI application.
    After connecting to the server by clicking the "Connect" button,
    drag the slider to set a setpoint, then click "Start" to start pumping water
    from the first tank to the second tank. After setting a setpoint lower than
    the current value of the second tank, a click on "Flush" opens the valve.

    If there is no water left, click "Reset simulation" to refill the first tank.

    \image tankexample.jpg
*/
